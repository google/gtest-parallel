#!/usr/bin/env python2
# Copyright 2013 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import cPickle
import errno
import gzip
import json
import multiprocessing
import optparse
import os
import re
import shutil
import signal
import subprocess
import sys
import tempfile
import thread
import threading
import time
import zlib


INF = float("inf")


# An object that catches SIGINT sent to the Python process and notices
# if processes passed to wait() die by SIGINT (we need to look for
# both of those cases, because pressing Ctrl+C can result in either
# the main process or one of the subprocesses getting the signal).
#
# Before a SIGINT is seen, wait(p) will simply call p.wait() and
# return the result. Once a SIGINT has been seen (in the main process
# or a subprocess, including the one the current call is waiting for),
# wait(p) will call p.terminate() and raise ProcessWasInterrupted.
class SigintHandler(object):
  class ProcessWasInterrupted(Exception): pass
  sigint_returncodes = {-signal.SIGINT,  # Unix
                        -1073741510,     # Windows
                        }
  def __init__(self):
    self.__lock = threading.Lock()
    self.__processes = set()
    self.__got_sigint = False
    signal.signal(signal.SIGINT, lambda signal_num, frame: self.interrupt())
  def __on_sigint(self):
    self.__got_sigint = True
    while self.__processes:
      try:
        self.__processes.pop().terminate()
      except OSError:
        pass
  def interrupt(self):
    with self.__lock:
      self.__on_sigint()
  def got_sigint(self):
    with self.__lock:
      return self.__got_sigint
  def wait(self, p):
    with self.__lock:
      if self.__got_sigint:
        p.terminate()
      self.__processes.add(p)
    code = p.wait()
    with self.__lock:
      self.__processes.discard(p)
      if code in self.sigint_returncodes:
        self.__on_sigint()
      if self.__got_sigint:
        raise self.ProcessWasInterrupted
    return code
sigint_handler = SigintHandler()

# Return the width of the terminal, or None if it couldn't be
# determined (e.g. because we're not being run interactively).
def term_width(out):
  if not out.isatty():
    return None
  try:
    p = subprocess.Popen(['stty', 'size'],
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (out, err) = p.communicate()
    if p.returncode != 0 or err:
      return None
    return int(out.split()[1])
  except (IndexError, OSError, ValueError):
    return None

# Output transient and permanent lines of text. If several transient
# lines are written in sequence, the new will overwrite the old. We
# use this to ensure that lots of unimportant info (tests passing)
# won't drown out important info (tests failing).
class Outputter(object):
  def __init__(self, out_file):
    self.__out_file = out_file
    self.__previous_line_was_transient = False
    self.__width = term_width(out_file)  # Line width, or None if not a tty.
  def transient_line(self, msg):
    if self.__width is None:
      self.__out_file.write(msg + '\n')
    else:
      self.__out_file.write('\r' + msg[:self.__width].ljust(self.__width))
      self.__previous_line_was_transient = True
  def flush_transient_output(self):
    if self.__previous_line_was_transient:
      self.__out_file.write('\n')
      self.__previous_line_was_transient = False
  def permanent_line(self, msg):
    self.flush_transient_output()
    self.__out_file.write(msg + '\n')


class Test(object):
  def __init__(self, test_id, name, binary, command):
    self.name = name
    self.binary = binary
    self.command = command
    self.test_id = test_id


class Task(object):
  def __init__(self, task_id, test, execution_number, last_execution_time,
               logger, output_dir, task_started_callback,
               task_finished_callback):
    self.test = test
    self.logger = logger
    self.task_id = task_id
    self.execution_number = execution_number
    self.last_execution_time = last_execution_time
    self.task_started_callback = task_started_callback
    self.task_finished_callback = task_finished_callback

    self.command = self.test.command + ['--gtest_filter=' + self.test.name]
    log_name = '%s-%s-%s.log' % (self.__normalize(self.test.binary),
                                 self.__normalize(self.test.name),
                                 self.execution_number)

    self.log_file = os.path.join(output_dir, log_name)

    self.exit_code = None
    self.runtime_ms = None

  def __normalize(self, string):
    return re.sub('[^A-Za-z0-9]', '_', string)

  def run(self):
    self.task_started_callback(self.task_id)
    self.logger.log(self.task_id, 'START')
    begin = time.time()
    with open(self.log_file, 'w') as log:
      task = subprocess.Popen(self.command, stdout=log, stderr=log)
      try:
        self.exit_code = sigint_handler.wait(task)
      except sigint_handler.ProcessWasInterrupted:
        thread.exit()
      self.runtime_ms = int(1000 * (time.time() - begin))
    self.logger.log(self.task_id, 'EXIT', (self.test.name, self.exit_code,
                                           self.runtime_ms),
                    self.log_file)
    self.task_finished_callback(self.task_id)


class ExecutionManager(object):
  def __init__(self, times_db, logger, output_dir, max_retries):
    self.logger = logger
    self.times_db = times_db
    self.output_dir = output_dir
    self.max_retries = max_retries

    self.tasks = []
    self.tests = []
    self.failed = []
    self.passed = []
    self.queued = []
    self.exit_code = 0
    self.started = set()
    self.tasks_by_test = {}

  def register_test(self, test_name, test_binary, test_command,
                    times_to_repeat):
    test_id = len(self.tests)
    self.tests.append(Test(test_id, test_name, test_binary, test_command))
    last_execution_time = self.times_db.get_test_time(test_binary, test_name)
    for execution_number in range(1, times_to_repeat + 1):
      self.register_task(test_id, execution_number, last_execution_time)

  def register_task(self, test_id, execution_number, last_execution_time):
    task_id = len(self.tasks)
    self.queued.append(task_id)
    self.tasks_by_test.setdefault(test_id, []).append(task_id)
    self.tasks.append(Task(task_id, self.tests[test_id], execution_number,
                           last_execution_time, self.logger, self.output_dir,
                           self.__task_started_callback,
                           self.__task_finished_callback))

  def get_tasks(self):
    tasks = [self.tasks[task_id] for task_id in self.queued]
    self.queued = []
    return sorted(tasks, key=lambda task: task.last_execution_time,
                  reverse=True)

  def __task_started_callback(self, task_id):
    self.started.add(task_id)

  def __task_finished_callback(self, task_id):
    self.started.remove(task_id)
    task = self.tasks[task_id]
    test_id = task.test.test_id
    self.times_db.record_test_time(task.test.binary, task.test.name,
                                   task.runtime_ms, task.exit_code)
    if task.exit_code == 0:
      self.passed.append(task_id)
    else:
      self.failed.append(task_id)
      self.exit_code = task.exit_code
      if len(self.tasks_by_test[test_id]) <= self.max_retries:
        self.register_task(test_id, len(self.tasks_by_test[test_id]) + 1,
                           task.runtime_ms)

  def get_failed_tasks(self):
    return [self.tasks[task_id] for task_id in self.failed]

  def get_passed_tasks(self):
    return [self.tasks[task_id] for task_id in self.passed]

  def get_started_tasks(self):
    return [self.tasks[task_id] for task_id in self.started]


class WorkerPool(object):
  def __init__(self, workers, tasks, timeout):
    self.tasks = tasks
    self.workers = workers
    self.timeout = timeout

    self.task_id = 0
    self.task_lock = threading.Lock()

  def __worker_function(self):
    while True:
      task = None
      with self.task_lock:
        if self.task_id < len(self.tasks):
          task = self.tasks[self.task_id]
        self.task_id += 1
      if task is None:
        return
      task.run()

  def __start_daemon(self):
    worker = threading.Thread(target=self.__worker_function)
    worker.daemon = True
    worker.start()
    return worker

  def run_tasks(self):
    try:
      self.timeout.start()
      workers = [self.__start_daemon() for _ in range(self.workers)]
      for worker in workers:
        worker.join()
    finally:
      self.timeout.cancel()


class FilterFormat:
  def __init__(self):
    if sys.stdout.isatty():
      # stdout needs to be unbuffered since the output is interactive.
      sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)
    self.stdout_lock = threading.Lock()
    self.out = Outputter(sys.stdout)
    self.total_tasks = 0
    self.finished_tasks = 0

  def print_tasks(self, message, tasks):
    self.out.permanent_line('%s (%s/%s):' %
                            (message, len(tasks), self.total_tasks))
    for task in tasks:
      self.out.permanent_line(' %s: %s run #%d' % (task.test.binary,
                                                   task.test.name,
                                                   task.execution_number))

  def print_test_status(self, last_finished_task, time_ms):
    self.out.transient_line('[%d/%d] %s (%d ms)'
                            % (self.finished_tasks, self.total_tasks,
                               last_finished_task, time_ms))

  def log(self, task_id, command, args=tuple(), file_name=None):
    with self.stdout_lock:
      if command == 'EXIT':
        self.finished_tasks += 1
        (test, exit_code, time_ms) = args
        self.print_test_status(test, time_ms)
        if exit_code:
          with open(file_name) as f:
            for line in f.readlines():
              self.out.permanent_line(line.rstrip())
          self.out.permanent_line(
            '[%d/%d] %s returned/aborted with exit code %d (%d ms)'
            % (self.finished_tasks, self.total_tasks, test, exit_code, time_ms))
      elif command == 'TESTCNT':
        self.total_tasks += args[0]
        self.out.transient_line('[0/%d] Running tests...' % self.total_tasks)

  def log_failed_and_interrupted_tasks(self, failed, interrupted):
    if failed:
      self.print_tasks('FAILED TESTS', failed)
    if interrupted:
      self.print_tasks('INTERRUPTED TESTS', interrupted)
    self.out.flush_transient_output()


class RawFormat:
  def __init__(self):
    self.stdout_lock = threading.Lock()

  def log(self, task_id, command, args=tuple(), file_name=None):
    with self.stdout_lock:
      line = '%d: %s %s' % (task_id, command,
                            ' '.join(str(arg) for arg in args))
      sys.stdout.write(line + '\n')
      if command == 'EXIT':
        with open(file_name) as f:
          for line in f:
            sys.stdout.write('%d > %s' % (task_id, line))
      sys.stdout.flush()
  def log_failed_and_interrupted_tasks(self, failed, interrupted):
    pass


class DummyTimer(object):
  def start(self):
    pass
  def cancel(self):
    pass


# Record of test runtimes. Has built-in locking.
class TestTimes(object):
  def __init__(self, save_file):
    'Create new object seeded with saved test times from the given file.'
    self.__times = {}  # (test binary, test name) -> (runtime in ms, exit_code)

    # Protects calls to record_test_time(); other calls are not
    # expected to be made concurrently.
    self.__lock = threading.Lock()

    try:
      with gzip.GzipFile(save_file, 'rb') as f:
        times = cPickle.load(f)
    except (EOFError, IOError, cPickle.UnpicklingError, zlib.error):
      # File doesn't exist, isn't readable, is malformed---whatever.
      # Just ignore it.
      return

    # Discard saved times if the format isn't right.
    if type(times) is not dict:
      return
    for key, value in times.items():
      if type(key) is not tuple or len(key) != 2:
        return
      if type(value) is not tuple or len(value) != 2:
        return
      (test_binary, test_name) = key
      (runtime, exit_code) = value
      if (type(test_binary) is not str or type(test_name) is not str
          or type(runtime) not in {int, long, float}
          or type(exit_code) not in {int, long}):
        return

    self.__times = times

  def get_test_time(self, binary, testname):
    """Return the last duration for the given test as an integer number of
    milliseconds, or None if the test failed or if there's no record for it."""
    if ((binary, testname) not in self.__times
        or self.__times[binary, testname][1] != 0):
      return INF
    return self.__times[binary, testname]

  def record_test_time(self, binary, testname, runtime_ms, exit_code):
    """Record that the given test ran in the specified number of
    milliseconds."""
    with self.__lock:
      self.__times[(binary, testname)] = (runtime_ms, exit_code)

  def write_to_file(self, save_file):
    """Write all the times to file."""
    try:
      with open(save_file, 'wb') as f:
        with gzip.GzipFile('', 'wb', 9, f) as gzf:
          cPickle.dump(self.__times, gzf, cPickle.HIGHEST_PROTOCOL)
    except IOError:
      pass  # ignore errors---saving the times isn't that important


def find_tests(binaries, gtest_filter, gtest_color,
               shard_index, shard_count, additional_args, times_to_repeat,
               run_disabled_tests, only_failed_and_new, times_db,
               execution_manager):
  test_count = 0
  for test_binary in binaries:
    test_command = [test_binary]
    if run_disabled_tests:
      test_command += ['--gtest_also_run_disabled_tests']

    list_tests_command = test_command + ['--gtest_list_tests']
    if gtest_filter != '':
      list_tests_command += ['--gtest_filter=' + gtest_filter]

    try:
      test_list = subprocess.Popen(list_tests_command,
                                   stdout=subprocess.PIPE).communicate()[0]
    except OSError as e:
      sys.exit('%s: %s' % (test_binary, str(e)))

    test_command += additional_args + ['--gtest_color=' + gtest_color]

    test_group = ''
    for line in test_list.split('\n'):
      if not line.strip():
        continue
      if line[0] != ' ':
        # Remove comments for typed tests and strip whitespace.
        test_group = line.split('#')[0].strip()
        continue
      # Remove comments for parameterized tests and strip whitespace.
      line = line.split('#')[0].strip()
      if not line:
        continue

      test_name = test_group + line
      if not run_disabled_tests and 'DISABLED_' in test_name:
        continue

      test_binary = os.path.basename(test_binary)
      last_execution_time = times_db.get_test_time(test_binary, test_name)
      # The last execution time is INF if the test is new or the most recent
      # run failed.
      if only_failed_and_new and last_execution_time != INF:
        continue

      if (test_count - shard_index) % shard_count == 0:
        execution_manager.register_test(test_name, test_binary, test_command,
                                        times_to_repeat)
      test_count += 1


def collect_test_results(execution_manager, json_dump_filepath):
  test_results = {
      'interrupted': False,
      'path_delimiter': '.',
      # Third version of the file format. See the link in the flag description
      # for details.
      'version': 3,
      'seconds_since_epoch': int(time.time()),
      'num_failures_by_type': {
          'PASS': 0,
          'FAIL': 0,
      },
      'tests': {},
  }

  for test_id, task_ids in execution_manager.tasks_by_test.items():
    times = []
    actual_results = []
    for task_id in task_ids:
      task = execution_manager.tasks[task_id]
      if not task.runtime_ms:
        continue
      actual_result = 'PASS' if task.exit_code == 0 else 'FAIL'
      test_results['num_failures_by_type'][actual_result] += 1
      actual_results.append(actual_result)
      times.append(task.runtime_ms)

    if not actual_results:
      continue

    results = test_results['tests']
    test = execution_manager.tests[test_id]
    for name in [test.binary] + test.name.split('.'):
      results = results.setdefault(name, {})

    results['expected'] = 'PASS'
    results['actual'] = ' '.join(actual_results)
    results['times'] = times
    results['time'] = times[0]

  with open(json_dump_filepath, 'w') as json_dump_file:
    json.dump(test_results, json_dump_file)


def move_logs_to(logs, output_dir):
  os.makedirs(output_dir)
  for log in logs:
    shutil.move(log, output_dir)


def main(output_dir, times_to_repeat, only_failed_and_new, workers, gtest_color,
         gtest_filter, run_disabled_tests, log_format, print_test_times,
         shard_count, shard_index, json_dump_filepath, timeout, retry_failures):
  # Remove files from old test runs.
  if os.path.isdir(output_dir):
    shutil.rmtree(output_dir)
  # Create directory for test log output.
  try:
    os.makedirs(output_dir)
  except OSError as e:
    # Ignore errors if this directory already exists.
    if e.errno != errno.EEXIST or not os.path.isdir(output_dir):
      raise e

  logger = (RawFormat() if log_format == 'raw' else FilterFormat())

  timeout = (DummyTimer() if timeout is None
             else threading.Timer(timeout, sigint_handler.interrupt))

  times_db_file = os.path.join(os.path.expanduser('~'), '.gtest-parallel-times')
  times_db = TestTimes(times_db_file)

  execution_manager = ExecutionManager(times_db, logger, output_dir,
                                       retry_failures)

  find_tests(binaries, gtest_filter, gtest_color, shard_index, shard_count,
             additional_args, times_to_repeat, run_disabled_tests,
             only_failed_and_new, times_db, execution_manager)

  tasks = execution_manager.get_tasks()
  while tasks:
    logger.log(-1, 'TESTCNT', (len(tasks),))
    worker_pool = WorkerPool(workers, tasks, timeout)
    worker_pool.run_tasks()

    tasks = execution_manager.get_tasks()

  failed_tasks = execution_manager.get_failed_tasks()
  passed_tasks = execution_manager.get_passed_tasks()
  interrupted_tasks = execution_manager.get_started_tasks()

  logger.log_failed_and_interrupted_tasks(failed_tasks, interrupted_tasks)

  times_db.write_to_file(times_db_file)
  if print_test_times:
    ts = sorted(filter(lambda task: task.runtime_ms < INF, tasks),
                key=lambda task: task.runtime_ms)
    for task in ts:
      task_runtime = '%dms' % task.runtime_ms
      print '%8s %s run #%d' % (task_runtime, task.test.name,
                                task.execution_number)

  if json_dump_filepath:
    collect_test_results(execution_manager, json_dump_filepath)

  if failed_tasks:
    move_logs_to([task.log_file for task in failed_tasks],
                 os.path.join(output_dir, "failed"))
  if passed_tasks:
    move_logs_to([task.log_file for task in passed_tasks],
                 os.path.join(output_dir, "passed"))
  if interrupted_tasks:
    move_logs_to([task.log_file for task in interrupted_tasks],
                 os.path.join(output_dir, "interrupted"))

  if sigint_handler.got_sigint():
    return -signal.SIGINT

  return execution_manager.exit_code


if __name__ == '__main__':
  additional_args = []

  for i in range(len(sys.argv)):
    if sys.argv[i] == '--':
      additional_args = sys.argv[i+1:]
      sys.argv = sys.argv[:i]
      break

  parser = optparse.OptionParser(
      usage = 'usage: %prog [options] binary [binary ...] -- [additional args]')

  parser.add_option('-d', '--output_dir', type='string',
                    default=os.path.join(tempfile.gettempdir(),
                                         'gtest-parallel'),
                    help='output directory for test logs')
  parser.add_option('-r', '--repeat', type='int', default=1,
                    help='repeat tests')
  parser.add_option('--failed', action='store_true', default=False,
                    help='run only failed and new tests')
  parser.add_option('-w', '--workers', type='int',
                    default=multiprocessing.cpu_count(),
                    help='number of workers to spawn')
  parser.add_option('--gtest_color', type='string', default='yes',
                    help='color output')
  parser.add_option('--gtest_filter', type='string', default='',
                    help='test filter')
  parser.add_option('--gtest_also_run_disabled_tests', action='store_true',
                    default=False, help='run disabled tests too')
  parser.add_option('--format', type='string', default='filter',
                    help='output format (raw,filter)')
  parser.add_option('--print_test_times', action='store_true', default=False,
                    help='list the run time of each test at the end of '
                         'execution')
  parser.add_option('--shard_count', type='int', default=1,
                    help='total number of shards (for sharding test execution '
                         'between multiple machines)')
  parser.add_option('--shard_index', type='int', default=0,
                    help='zero-indexed number identifying this shard (for '
                         'sharding test execution between multiple machines)')
  parser.add_option('--dump_json_test_results', type='string', default=None,
                    help='Saves the results of the tests as a JSON machine-'
                         'readable file. The format of the file is specified '
                         'at https://www.chromium.org/developers/the-json-test-results-format')
  parser.add_option('--timeout', type='int', default=None,
                    help='Interrupt all remaining processes after the given '
                         'time (in seconds).')
  parser.add_option('--retry_failures', type='int', default=0,
                    help='Number of times to retry failing tests.')

  (options, binaries) = parser.parse_args()

  if binaries == []:
    parser.print_usage()
    sys.exit(1)

  # Check that all test binaries have an unique basename. That way we can ensure
  # the logs are saved to unique files even when two different binaries have
  # common tests.
  unique_binaries = set(os.path.basename(binary) for binary in binaries)
  assert len(unique_binaries) == len(binaries), (
      'All test binaries must have an unique basename.')


  if options.format not in ('filter', 'raw'):
    parser.error('Unknown output format: ' + options.format)

  if options.shard_count < 1:
    parser.error('Invalid number of shards: %d. Must be at least 1.' %
                 options.shard_count)
  if not (0 <= options.shard_index < options.shard_count):
    parser.error('Invalid shard index: %d. Must be between 0 and %d '
                 '(less than the number of shards).' %
                 (options.shard_index, options.shard_count - 1))

  sys.exit(main(options.output_dir, options.repeat, options.failed,
                options.workers, options.gtest_color, options.gtest_filter,
                options.gtest_also_run_disabled_tests, options.format,
                options.print_test_times, options.shard_count,
                options.shard_index, options.dump_json_test_results,
                options.timeout, options.retry_failures))
